#include "denm_infra.h"

#include <inttypes.h>

#include "common/globals.h"
#include "boundary/serial_output.h"

/**
 * @brief denm_infra_init
 * Initialize the DENM message buffer.
 *
 * @param psStationInfo - Current station info.
 */
void denm_infra_init(SITSStationInfo *psStationInfo) {

    /* Make sure we reset the data structure at least once. */
    memset((void *)&denm_tx_encode_fmt, 0, sizeof(denm_tx_encode_fmt));

    // Set header info.

    /* For the present document, the value of the DE protocolVersion shall be set to 1.  */
    denm_tx_encode_fmt.header.protocolVersion = DENM_PROTOCOL_VERSION;
    denm_tx_encode_fmt.header.messageID = DENM_Id;
    denm_tx_encode_fmt.header.stationID = psStationInfo->m_un32StationId;

    /* Identifier generated by the DEN basic service for new DENM. */
    denm_tx_encode_fmt.denm.management.actionID.originatingStationID = psStationInfo->m_un32StationId; /* StationID (0..4294967295) */
    denm_tx_encode_fmt.denm.management.actionID.sequenceNumber = DENM_ACTION_SEQUENCE(); /* SequenceNumber (0..65535) */

    /* This DE provides the station type information of the originating ITS-S. */
    denm_tx_encode_fmt.denm.management.stationType = psStationInfo->m_n32StationType;
}

/**
 * @brief denm_infra_encode
 * Prepare a DENM message used paramters and last known configurations.
 *
 * @param pp_denm_data - The data to send.
 * @param p_fix_data - The fix data from gps.
 *
 * @return 0 on success or error code.
 */
int32_t denm_infra_encode(uint8_t **pp_denm_data, fix_data_t *p_fix_data, ITSMsgCodecErr *psOutputErr) {

    int32_t n32EncodedBufferLength = 0;

    // ---------------------------------------------------------
    // --------------- Set Management Options ------------------
    // ---------------------------------------------------------

    /*
     * Time at which the event is detected by the originating ITS-S. For the DENM repetition, this DE shall remain unchanged.
     * For the DENM update, this DE shall be the time at which the event update is detected.
     * For the DENM termination, this DE shall be the time at which the termination of the event is detected.
     *
     * Number of milliseconds since 2004-01-01T00:00:00.000Z, as specified in ISO 8601 [i.10].
     */
    asn1_new_integer_u64(&denm_tx_encode_fmt.denm.management.detectionTime, (uint64_t)DENM_EVENT_GET_POSITION_TIME());

    /*
     * This DE refers to the time at which a new DENM, an update DENM or a cancellation DENM is generated.
     *
     * Number of milliseconds since 2004-01-01T00:00:00.000Z, as specified in ISO 8601 [i.10].
     */
    asn1_new_integer_u64(&denm_tx_encode_fmt.denm.management.referenceTime, (uint64_t)fmod(p_fix_data->time.tai_since_2004 * 1000.0, 65536));

    /* This DE indicates if the type of generated DENM is a cancellation DENM or a negation DENM. */
    denm_tx_encode_fmt.denm.management.termination_option = FALSE; /* Send DENM_trigger for demonstration, no need to enable termination field. */
    //denm_tx_encode_fmt.denm.management.termination =

    /* Geographical position of the detected event. */
    denm_tx_encode_fmt.denm.management.eventPosition.latitude = (int32_t)(DENM_EVENT_GET_POSITION_LAT() * 10000000.0); /* Convert to 1/10 micro degree. */
    denm_tx_encode_fmt.denm.management.eventPosition.longitude = (int32_t)(DENM_EVENT_GET_POSITION_LONG() * 10000000.0); /* Convert to 1/10 micro degree. */
    denm_tx_encode_fmt.denm.management.eventPosition.positionConfidenceEllipse.semiMajorConfidence = DENM_EVENT_GET_POSITION_MAJOR_CONFIDENCE(); /* Convert to centimetre. */
    denm_tx_encode_fmt.denm.management.eventPosition.positionConfidenceEllipse.semiMinorConfidence = DENM_EVENT_GET_POSITION_MINOR_CONFIDENCE(); /* Convert to centimetre. */
    denm_tx_encode_fmt.denm.management.eventPosition.positionConfidenceEllipse.semiMajorOrientation = (int32_t)(DENM_EVENT_GET_POSITION_MAJOR_ORIENTATION() * 10.0); /* Convert to 0.1 degree from North. */
    denm_tx_encode_fmt.denm.management.eventPosition.altitude.altitudeValue = (int32_t)(p_fix_data->altitude * 100.0); /* Convert to 0.01 metre. */
    denm_tx_encode_fmt.denm.management.eventPosition.altitude.altitudeConfidence = DENM_EVENT_GET_POSITION_ALT_CONFIDENCE();

    /* The distance within which the event is considered relevant to the receiving ITS-S. */
    denm_tx_encode_fmt.denm.management.relevanceDistance_option = FALSE;
    //denm_tx_encode_fmt.denm.management.relevanceDistance =

    /* The traffic direction along which the event information is relevant for the receiving ITS-S. */
    denm_tx_encode_fmt.denm.management.relevanceTrafficDirection_option = FALSE;
    //denm_tx_encode_fmt.denm.management.relevanceTrafficDirection =

    /* Validity duration of a DENM. */
    denm_tx_encode_fmt.denm.management.validityDuration = DENM_VALIDITY_DURATION_DEF; /* ValidityDuration (0..86400) */

    /* Time interval for DENM transmission as defined by the originating ITS-S. */
    denm_tx_encode_fmt.denm.management.transmissionInterval_option = FALSE;
    //denm_tx_encode_fmt.denm.management.transmissionInterval = /* TransmissionInterval (1..10000) */

    // ---------------------------------------------------------
    // ---------------- Set Situation Options ------------------
    // ---------------------------------------------------------

    /*
     *  The situation container includes information that describes the detected event.
     */
    denm_tx_encode_fmt.denm.situation_option = TRUE; // TRUE; TODO DEBUG
    denm_tx_encode_fmt.denm.situation.informationQuality = 0; /* InformationQuality (0..7), If the information is unknown, the DE shall be set to 0. */
    denm_tx_encode_fmt.denm.situation.eventType.causeCode = 0; //CauseCodeType_redLight; //TODO DEUBG
    denm_tx_encode_fmt.denm.situation.eventType.subCauseCode = 0; // WrongWayDrivingSubCauseCode_unavailable; // TODO DEBUG

    denm_tx_encode_fmt.denm.situation.linkedCause_option = FALSE;
    //denm_tx_encode_fmt.denm.situation.linkedCause =
    denm_tx_encode_fmt.denm.situation.eventHistory_option = FALSE;
    //denm_tx_encode_fmt.denm.situation.eventHistory =

    // ---------------------------------------------------------
    // ---------------- Set Location Options -------------------
    // ---------------------------------------------------------

    /*
     * The location container describes the location of the detected event.
     */
    denm_tx_encode_fmt.denm.location_option = TRUE;
    denm_tx_encode_fmt.denm.location.eventSpeed_option = TRUE;
    denm_tx_encode_fmt.denm.location.eventSpeed.speedValue = SpeedValue_unavailable; /* 0,01 m/s */
    denm_tx_encode_fmt.denm.location.eventSpeed.speedConfidence = SpeedConfidence_equalOrWithinOneMeterPerSec;
    denm_tx_encode_fmt.denm.location.eventPositionHeading_option = FALSE;
    //denm_tx_encode_fmt.denm.location.eventPositionHeading =

    /* Allocate and initialize each entries and paths. */
    denm_tx_encode_fmt.denm.location.traces.count = 1;
    denm_tx_encode_fmt.denm.location.traces.tab = (PathHistory_ITS *)calloc(sizeof(PathHistory_ITS), denm_tx_encode_fmt.denm.location.traces.count);
    denm_tx_encode_fmt.denm.location.traces.tab[0].count = 2;
    denm_tx_encode_fmt.denm.location.traces.tab[0].tab = (PathPoint *)calloc(sizeof(PathPoint), denm_tx_encode_fmt.denm.location.traces.tab[0].count);
    denm_tx_encode_fmt.denm.location.traces.tab[0].tab[0].pathPosition.deltaLatitude = -123010;
    denm_tx_encode_fmt.denm.location.traces.tab[0].tab[0].pathPosition.deltaLongitude = -131068;
    denm_tx_encode_fmt.denm.location.traces.tab[0].tab[0].pathPosition.deltaAltitude = -12693;
    denm_tx_encode_fmt.denm.location.traces.tab[0].tab[1].pathPosition.deltaLatitude = -131058;
    denm_tx_encode_fmt.denm.location.traces.tab[0].tab[1].pathPosition.deltaLongitude = -131055;
    denm_tx_encode_fmt.denm.location.traces.tab[0].tab[1].pathPosition.deltaAltitude = -11769;
    denm_tx_encode_fmt.denm.location.traces.tab[0].tab[1].pathDeltaTime_option = TRUE;
    denm_tx_encode_fmt.denm.location.traces.tab[0].tab[1].pathDeltaTime = -151310;

    denm_tx_encode_fmt.denm.location.roadType_option = FALSE;
    //denm_tx_encode_fmt.denm.location.roadType

    // ---------------------------------------------------------
    // ---------------- Set ALACARTE Options -------------------
    // ---------------------------------------------------------

    /*
     * The a la carte container contains additional information that is not provided by other containers.
     */
    denm_tx_encode_fmt.denm.alacarte_option = FALSE;
    //denm_tx_encode_fmt.denm.alacarte.lanePosition_option =
    //denm_tx_encode_fmt.denm.alacarte.lanePosition =
    //denm_tx_encode_fmt.denm.alacarte.impactReduction_option =
    //denm_tx_encode_fmt.denm.alacarte.externalTemperature_option =
    //denm_tx_encode_fmt.denm.alacarte.externalTemperature =
    //denm_tx_encode_fmt.denm.alacarte.roadWorks_option =
    //denm_tx_encode_fmt.denm.alacarte.roadWorks =
    //denm_tx_encode_fmt.denm.alacarte.positioningSolution_option =
    //denm_tx_encode_fmt.denm.alacarte.positioningSolution =
    //denm_tx_encode_fmt.denm.alacarte.stationaryVehicle_option =
    //denm_tx_encode_fmt.denm.alacarte.stationaryVehicle =

    // ---------------------------------------------------------
    // ----------------- Encode ITS Message --------------------
    // ---------------------------------------------------------

    n32EncodedBufferLength = itsmsg_encode(pp_denm_data, (ItsPduHeader *)&denm_tx_encode_fmt, psOutputErr);

    /* Release allocated memory. */
    free(denm_tx_encode_fmt.denm.location.traces.tab[0].tab);
    free(denm_tx_encode_fmt.denm.location.traces.tab);
    asn1_free_integer(&denm_tx_encode_fmt.denm.management.detectionTime);
    asn1_free_integer(&denm_tx_encode_fmt.denm.management.referenceTime);

    return n32EncodedBufferLength;
}

/**
 * @brief denm_infra_decode
 * Decode a received DENM message.
 *
 * @param p_rx_payload
 * @param rx_payload_len
 * @param p_recv_ind
 * @param ssp_check
 * @param psOutputDenm
 * @param psOutputErr
 *
 * @return - 0 if sucessfull else error code.
 */
int32_t denm_infra_decode(uint8_t *p_rx_payload, int32_t rx_payload_len, btp_handler_recv_indicator_t *p_recv_ind, bool bSspCheck, DENM *psOutputDenm, ITSMsgCodecErr *psOutputErr) {

    ItsPduHeader *psItsHeader = NULL;
    uint64_t detection_time;
    uint64_t reference_time;
    int32_t n32Result = PROCEDURE_SUCCESSFULL;

    if(p_recv_ind == NULL
            || p_rx_payload == NULL
            || rx_payload_len == 0
            || NULL == psOutputDenm
            || NULL == psOutputErr) {

        return PROCEDURE_INVALID_PARAMETERS_ERROR;
    }

    /* Check whether this is a ITS message. */
    if(0 < (itsmsg_decode(&psItsHeader, p_rx_payload, rx_payload_len, psOutputErr))) {

        /* Check whether this is a ITS CAM message. */
        if(DENM_Id == psItsHeader->messageID) {

            if(TRUE == bSspCheck) {

                /* Check CAM msg permission */
                n32Result = denm_check_msg_permission(psOutputDenm, p_recv_ind->security.ssp, p_recv_ind->security.ssp_len);
                if(FALSE == IS_SUCCESS(n32Result)) {

                    printf("Received DENM message is untrustworthy\n");
                    n32Result = PROCEDURE_SECURITY_ERROR;

                } else {

                    memcpy(psOutputDenm, psItsHeader, sizeof(DENM));

            /* Display the decoded DENM content. */
//            printf("[ Received DENM from station %d ]\n", p_rx_decode_denm->header.stationID);
//            printf("\tSource LL_ADDR: %02X:%02X:%02X:%02X:%02X:%02X\n",
//                   p_recv_ind->src_pv.addr.mid[0], p_recv_ind->src_pv.addr.mid[1],
//                   p_recv_ind->src_pv.addr.mid[2], p_recv_ind->src_pv.addr.mid[3],
//                   p_recv_ind->src_pv.addr.mid[4], p_recv_ind->src_pv.addr.mid[5]);
//            printf("\toriginatingStationID: %u\n", p_rx_decode_denm->denm.management.actionID.originatingStationID);
//            printf("\tsequenceNumber: %u\n", p_rx_decode_denm->denm.management.actionID.sequenceNumber);

                    asn1_get_integer_si64_ov(&psOutputDenm->denm.management.detectionTime, (int64_t *)&detection_time);
//            printf("\tdetectionTime: %" PRIu64 "\n", detection_time);

                    asn1_get_integer_si64_ov(&psOutputDenm->denm.management.referenceTime, (int64_t *)&reference_time);
//            printf("\treferenceTime: %" PRIu64 "\n", reference_time);

//            printf("\tEvent latitude: %d\n", p_rx_decode_denm->denm.management.eventPosition.latitude);
//            printf("\tEvent longitude: %d\n", p_rx_decode_denm->denm.management.eventPosition.longitude);
                }
            }

        } else {

            printf("Received unrecognized ITS message type: %d\n", psItsHeader->messageID);
        }
    }

    return n32Result;
}

/**
 * function_example - Function example
 *
 * @param   [in]    input       Example input.
 * @param   [out]   *p_output   Example output.
 *
 * @return  [int]   Function executing result.
 * @retval  [0]     Success.
 * @retval  [-1]    Fail.
 *
 */
static int32_t denm_check_msg_permission(DENM *p_denm_msg, uint8_t *p_ssp, uint32_t ssp_len) {

    int32_t rc = 0;
    if (ssp_len < DENM_SSP_LEN) {
        rc = -1;
        printf("Err: SSP length[%d] is not enough\n", ssp_len);
        goto FAILURE;
    }

    if (p_denm_msg->denm.situation_option) {
        /*
         *   For example, only check wrongWayDriving
         *   Please refer to ETSI EN 302 637-3 to check related SSP item
         */
        switch (p_denm_msg->denm.situation.eventType.causeCode) {
            case CauseCodeType_wrongWayDriving:
                if (DENM_SSP_CHECK(WRONG_WAY_DRIVING, p_ssp[2]) == false) {
                    printf("Err: certificate not allowed to sign WRONG_WAY_DRIVING\n");
                    rc = -1;
                    goto FAILURE;
                }
                break;
            default:
                // nothing
                break;
        }
    }

FAILURE:
    return rc;
}
